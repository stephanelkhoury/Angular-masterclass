{"ast":null,"code":"import { createEffect, ofType } from '@ngrx/effects';\nimport { of } from 'rxjs';\nimport { map, catchError, exhaustMap, tap, withLatestFrom } from 'rxjs/operators';\nimport * as CartActions from '../actions/cart.actions';\nimport { selectCartItems } from '../selectors/cart.selectors';\nimport { selectIsAuthenticated } from '../selectors/auth.selectors';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/effects\";\nimport * as i2 from \"../../core/services/cart.service\";\nimport * as i3 from \"../../core/services/storage.service\";\nimport * as i4 from \"../../core/services/notification.service\";\nimport * as i5 from \"@ngrx/store\";\nlet CartEffects = /*#__PURE__*/(() => {\n  class CartEffects {\n    constructor(actions$, cartService, storageService, notificationService, store) {\n      this.actions$ = actions$;\n      this.cartService = cartService;\n      this.storageService = storageService;\n      this.notificationService = notificationService;\n      this.store = store;\n      this.loadCart$ = createEffect(() => this.actions$.pipe(ofType(CartActions.loadCart), withLatestFrom(this.store.select(selectIsAuthenticated)), exhaustMap(([_, isAuthenticated]) => {\n        if (isAuthenticated) {\n          return this.cartService.getCart().pipe(map(items => CartActions.loadCartSuccess({\n            items\n          })), catchError(error => of(CartActions.loadCartFailure({\n            error\n          }))));\n        } else {\n          const localCart = this.storageService.getItem('cart') || '[]';\n          try {\n            const items = JSON.parse(localCart);\n            return of(CartActions.loadCartSuccess({\n              items\n            }));\n          } catch (error) {\n            return of(CartActions.loadCartFailure({\n              error: 'Failed to parse cart data'\n            }));\n          }\n        }\n      })));\n      this.addToCart$ = createEffect(() => this.actions$.pipe(ofType(CartActions.addToCart), withLatestFrom(this.store.select(selectCartItems), this.store.select(selectIsAuthenticated)), tap(([action, currentItems, isAuthenticated]) => {\n        this.notificationService.showSuccess(`${action.item.name || action.item.productId} added to cart`);\n        // Only update localStorage for non-authenticated users\n        // The reducer will handle the state update\n        if (!isAuthenticated) {\n          // Sync with localStorage after reducer updates state\n          setTimeout(() => {\n            const updatedItems = [...currentItems];\n            const existingItemIndex = updatedItems.findIndex(cartItem => cartItem.productId === action.item.productId);\n            if (existingItemIndex >= 0) {\n              updatedItems[existingItemIndex] = {\n                ...updatedItems[existingItemIndex],\n                quantity: updatedItems[existingItemIndex].quantity + action.item.quantity\n              };\n            } else {\n              const cartItem = {\n                productId: action.item.productId,\n                name: action.item.name || '',\n                price: action.item.price,\n                image: action.item.image || action.item.imageUrl || '',\n                quantity: action.item.quantity\n              };\n              updatedItems.push(cartItem);\n            }\n            this.storageService.setItem('cart', JSON.stringify(updatedItems));\n          }, 0);\n        }\n      })), {\n        dispatch: false\n      });\n      this.removeFromCart$ = createEffect(() => this.actions$.pipe(ofType(CartActions.removeFromCart), map(action => action.productId),\n      // Extract productId\n      withLatestFrom(this.store.select(selectCartItems), this.store.select(selectIsAuthenticated)), tap(([productId, currentItems, _]) => {\n        const item = currentItems.find(item => item.productId === productId);\n        if (item) {\n          this.notificationService.showInfo(`${item.name} removed from cart`);\n        }\n      }), exhaustMap(([productId, currentItems, isAuthenticated]) => {\n        const updatedItems = currentItems.filter(item => item.productId !== productId);\n        this.storageService.setItem('cart', JSON.stringify(updatedItems));\n        if (isAuthenticated) {\n          return this.cartService.syncCart(updatedItems).pipe(map(() => CartActions.syncCartWithServerSuccess()), catchError(error => of(CartActions.syncCartWithServerFailure({\n            error\n          }))));\n        }\n        return of(CartActions.syncCartWithServerSuccess());\n      })));\n      this.updateCartItemQuantity$ = createEffect(() => this.actions$.pipe(ofType(CartActions.updateCartItemQuantity), map(action => ({\n        productId: action.productId,\n        quantity: action.quantity\n      })),\n      // Extract properties\n      withLatestFrom(this.store.select(selectCartItems), this.store.select(selectIsAuthenticated)), exhaustMap(([{\n        productId,\n        quantity\n      }, currentItems, isAuthenticated]) => {\n        const updatedItems = currentItems.map(item => item.productId === productId ? {\n          ...item,\n          quantity\n        } : item);\n        this.storageService.setItem('cart', JSON.stringify(updatedItems));\n        if (isAuthenticated) {\n          return this.cartService.syncCart(updatedItems).pipe(map(() => CartActions.syncCartWithServerSuccess()), catchError(error => of(CartActions.syncCartWithServerFailure({\n            error\n          }))));\n        }\n        return of(CartActions.syncCartWithServerSuccess());\n      })));\n      this.clearCart$ = createEffect(() => this.actions$.pipe(ofType(CartActions.clearCart), withLatestFrom(this.store.select(selectIsAuthenticated)), exhaustMap(([action, isAuthenticated]) => {\n        if (isAuthenticated) {\n          // Simulate API call to clear backend cart\n          return of({\n            type: '[Cart API] Clear Cart Success - Backend (Placeholder)'\n          }).pipe(map(() => CartActions.loadCartSuccess({\n            items: []\n          })), catchError(error => of({\n            type: '[Cart API] Clear Cart Failure - Backend',\n            error\n          })));\n        } else {\n          // For non-authenticated users, just return success\n          return of(CartActions.loadCartSuccess({\n            items: []\n          }));\n        }\n      })));\n    }\n    static {\n      this.ɵfac = function CartEffects_Factory(t) {\n        return new (t || CartEffects)(i0.ɵɵinject(i1.Actions), i0.ɵɵinject(i2.CartService), i0.ɵɵinject(i3.StorageService), i0.ɵɵinject(i4.NotificationService), i0.ɵɵinject(i5.Store));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: CartEffects,\n        factory: CartEffects.ɵfac\n      });\n    }\n  }\n  return CartEffects;\n})();\nexport { CartEffects };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}