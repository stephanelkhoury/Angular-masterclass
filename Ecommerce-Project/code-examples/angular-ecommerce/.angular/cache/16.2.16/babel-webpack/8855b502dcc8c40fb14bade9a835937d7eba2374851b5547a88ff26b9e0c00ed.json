{"ast":null,"code":"import { createEffect, ofType } from '@ngrx/effects';\nimport { of } from 'rxjs';\nimport { map, catchError, exhaustMap, tap, withLatestFrom } from 'rxjs/operators';\nimport * as CartActions from '../actions/cart.actions';\nimport { selectCartItems } from '../selectors/cart.selectors';\nimport { selectIsAuthenticated } from '../selectors/auth.selectors';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/effects\";\nimport * as i2 from \"../../core/services/cart.service\";\nimport * as i3 from \"../../core/services/storage.service\";\nimport * as i4 from \"../../core/services/notification.service\";\nimport * as i5 from \"@ngrx/store\";\nclass CartEffects {\n  constructor(actions$, cartService, storageService, notificationService, store) {\n    this.actions$ = actions$;\n    this.cartService = cartService;\n    this.storageService = storageService;\n    this.notificationService = notificationService;\n    this.store = store;\n    this.loadCart$ = createEffect(() => this.actions$.pipe(ofType(CartActions.loadCart), withLatestFrom(this.store.select(selectIsAuthenticated)), exhaustMap(([_, isAuthenticated]) => {\n      if (isAuthenticated) {\n        return this.cartService.getCart().pipe(map(items => CartActions.loadCartSuccess({\n          items\n        })), catchError(error => of(CartActions.loadCartFailure({\n          error\n        }))));\n      } else {\n        const localCart = this.storageService.getItem('cart') || '[]';\n        try {\n          const items = JSON.parse(localCart);\n          return of(CartActions.loadCartSuccess({\n            items\n          }));\n        } catch (error) {\n          return of(CartActions.loadCartFailure({\n            error: 'Failed to parse cart data'\n          }));\n        }\n      }\n    })));\n    this.addToCart$ = createEffect(() => this.actions$.pipe(ofType(CartActions.addToCart), withLatestFrom(this.store.select(selectCartItems), this.store.select(selectIsAuthenticated)), tap(([action, currentItems, isAuthenticated]) => {\n      this.notificationService.showSuccess(`${action.item.name || action.item.productId} added to cart`);\n      // Only update localStorage for non-authenticated users\n      // The reducer will handle the state update\n      if (!isAuthenticated) {\n        // Sync with localStorage after reducer updates state\n        setTimeout(() => {\n          const updatedItems = [...currentItems];\n          const existingItemIndex = updatedItems.findIndex(cartItem => cartItem.productId === action.item.productId);\n          if (existingItemIndex >= 0) {\n            updatedItems[existingItemIndex] = {\n              ...updatedItems[existingItemIndex],\n              quantity: updatedItems[existingItemIndex].quantity + action.item.quantity\n            };\n          } else {\n            const cartItem = {\n              productId: action.item.productId,\n              name: action.item.name || '',\n              price: action.item.price,\n              image: action.item.image || action.item.imageUrl || '',\n              quantity: action.item.quantity\n            };\n            updatedItems.push(cartItem);\n          }\n          this.storageService.setItem('cart', JSON.stringify(updatedItems));\n        }, 0);\n      }\n    })), {\n      dispatch: false\n    });\n    this.removeFromCart$ = createEffect(() => this.actions$.pipe(ofType(CartActions.removeFromCart), map(action => action.productId),\n    // Extract productId\n    withLatestFrom(this.store.select(selectCartItems), this.store.select(selectIsAuthenticated)), tap(([productId, currentItems, _]) => {\n      const item = currentItems.find(item => item.productId === productId);\n      if (item) {\n        this.notificationService.showInfo(`${item.name} removed from cart`);\n      }\n    }), exhaustMap(([productId, currentItems, isAuthenticated]) => {\n      const updatedItems = currentItems.filter(item => item.productId !== productId);\n      this.storageService.setItem('cart', JSON.stringify(updatedItems));\n      if (isAuthenticated) {\n        return this.cartService.syncCart(updatedItems).pipe(map(() => CartActions.syncCartWithServerSuccess()), catchError(error => of(CartActions.syncCartWithServerFailure({\n          error\n        }))));\n      }\n      return of(CartActions.syncCartWithServerSuccess());\n    })));\n    this.updateCartItemQuantity$ = createEffect(() => this.actions$.pipe(ofType(CartActions.updateCartItemQuantity), map(action => ({\n      productId: action.productId,\n      quantity: action.quantity\n    })),\n    // Extract properties\n    withLatestFrom(this.store.select(selectCartItems), this.store.select(selectIsAuthenticated)), exhaustMap(([{\n      productId,\n      quantity\n    }, currentItems, isAuthenticated]) => {\n      const updatedItems = currentItems.map(item => item.productId === productId ? {\n        ...item,\n        quantity\n      } : item);\n      this.storageService.setItem('cart', JSON.stringify(updatedItems));\n      if (isAuthenticated) {\n        return this.cartService.syncCart(updatedItems).pipe(map(() => CartActions.syncCartWithServerSuccess()), catchError(error => of(CartActions.syncCartWithServerFailure({\n          error\n        }))));\n      }\n      return of(CartActions.syncCartWithServerSuccess());\n    })));\n    this.clearCart$ = createEffect(() => this.actions$.pipe(ofType(CartActions.clearCart), withLatestFrom(this.store.select(selectIsAuthenticated)), exhaustMap(([action, isAuthenticated]) => {\n      if (isAuthenticated) {\n        // Simulate API call to clear backend cart\n        return of({\n          type: '[Cart API] Clear Cart Success - Backend (Placeholder)'\n        }).pipe(map(() => CartActions.loadCartSuccess({\n          items: []\n        })), catchError(error => of({\n          type: '[Cart API] Clear Cart Failure - Backend',\n          error\n        })));\n      } else {\n        // For non-authenticated users, just return success\n        return of(CartActions.loadCartSuccess({\n          items: []\n        }));\n      }\n    })));\n  }\n  static {\n    this.ɵfac = function CartEffects_Factory(t) {\n      return new (t || CartEffects)(i0.ɵɵinject(i1.Actions), i0.ɵɵinject(i2.CartService), i0.ɵɵinject(i3.StorageService), i0.ɵɵinject(i4.NotificationService), i0.ɵɵinject(i5.Store));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: CartEffects,\n      factory: CartEffects.ɵfac\n    });\n  }\n}\nexport { CartEffects };","map":{"version":3,"names":["createEffect","ofType","of","map","catchError","exhaustMap","tap","withLatestFrom","CartActions","selectCartItems","selectIsAuthenticated","CartEffects","constructor","actions$","cartService","storageService","notificationService","store","loadCart$","pipe","loadCart","select","_","isAuthenticated","getCart","items","loadCartSuccess","error","loadCartFailure","localCart","getItem","JSON","parse","addToCart$","addToCart","action","currentItems","showSuccess","item","name","productId","setTimeout","updatedItems","existingItemIndex","findIndex","cartItem","quantity","price","image","imageUrl","push","setItem","stringify","dispatch","removeFromCart$","removeFromCart","find","showInfo","filter","syncCart","syncCartWithServerSuccess","syncCartWithServerFailure","updateCartItemQuantity$","updateCartItemQuantity","clearCart$","clearCart","type","i0","ɵɵinject","i1","Actions","i2","CartService","i3","StorageService","i4","NotificationService","i5","Store","factory","ɵfac"],"sources":["/Users/stephanelkhoury/Documents/GitHub/Angular-masterclass/Ecommerce-Project/code-examples/angular-ecommerce/src/app/store/effects/cart.effects.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport { Store } from '@ngrx/store';\nimport { of } from 'rxjs';\nimport { map, catchError, exhaustMap, tap, withLatestFrom } from 'rxjs/operators';\n\nimport { CartService } from '../../core/services/cart.service';\nimport { NotificationService } from '../../core/services/notification.service';\nimport { StorageService } from '../../core/services/storage.service';\nimport { CartItem } from '../../core/models/cart-item.model';\nimport { AppState } from '../index';\nimport * as CartActions from '../actions/cart.actions';\nimport * as UiActions from '../actions/ui.actions';\nimport { selectCartItems } from '../selectors/cart.selectors';\nimport { selectIsAuthenticated } from '../selectors/auth.selectors';\n\n@Injectable()\nexport class CartEffects {\n  loadCart$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(CartActions.loadCart),\n      withLatestFrom(this.store.select(selectIsAuthenticated)),\n      exhaustMap(([_, isAuthenticated]) => {\n        if (isAuthenticated) {\n          return this.cartService.getCart().pipe(\n            map(items => CartActions.loadCartSuccess({ items })),\n            catchError(error => of(CartActions.loadCartFailure({ error })))\n          );\n        } else {\n          const localCart = this.storageService.getItem<string>('cart') || '[]';\n          try {\n            const items = JSON.parse(localCart);\n            return of(CartActions.loadCartSuccess({ items }));\n          } catch (error) {\n            return of(CartActions.loadCartFailure({ error: 'Failed to parse cart data' }));\n          }\n        }\n      })\n    )\n  );\n\n  addToCart$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(CartActions.addToCart),\n      withLatestFrom(\n        this.store.select(selectCartItems),\n        this.store.select(selectIsAuthenticated)\n      ),\n      tap(([action, currentItems, isAuthenticated]) => {\n        this.notificationService.showSuccess(`${action.item.name || action.item.productId} added to cart`);\n        \n        // Only update localStorage for non-authenticated users\n        // The reducer will handle the state update\n        if (!isAuthenticated) {\n          // Sync with localStorage after reducer updates state\n          setTimeout(() => {\n            const updatedItems = [...currentItems];\n            const existingItemIndex = updatedItems.findIndex(cartItem => cartItem.productId === action.item.productId);\n\n            if (existingItemIndex >= 0) {\n              updatedItems[existingItemIndex] = {\n                ...updatedItems[existingItemIndex],\n                quantity: updatedItems[existingItemIndex].quantity + action.item.quantity\n              };\n            } else {\n              const cartItem: CartItem = {\n                productId: action.item.productId,\n                name: action.item.name || '',\n                price: action.item.price,\n                image: action.item.image || action.item.imageUrl || '',\n                quantity: action.item.quantity\n              };\n              updatedItems.push(cartItem);\n            }\n            \n            this.storageService.setItem('cart', JSON.stringify(updatedItems));\n          }, 0);\n        }\n      })\n    ),\n    { dispatch: false }\n  );\n\n  removeFromCart$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(CartActions.removeFromCart),\n      map(action => action.productId), // Extract productId\n      withLatestFrom(\n        this.store.select(selectCartItems),\n        this.store.select(selectIsAuthenticated)\n      ),\n      tap(([productId, currentItems, _]) => { // Use extracted productId\n        const item = currentItems.find(item => item.productId === productId);\n        if (item) {\n          this.notificationService.showInfo(`${item.name} removed from cart`);\n        }\n      }),\n      exhaustMap(([productId, currentItems, isAuthenticated]) => { // Use extracted productId\n        const updatedItems = currentItems.filter(item => item.productId !== productId);\n        this.storageService.setItem('cart', JSON.stringify(updatedItems));\n\n        if (isAuthenticated) {\n          return this.cartService.syncCart(updatedItems).pipe(\n            map(() => CartActions.syncCartWithServerSuccess()),\n            catchError(error => of(CartActions.syncCartWithServerFailure({ error })))\n          );\n        }\n        \n        return of(CartActions.syncCartWithServerSuccess());\n      })\n    )\n  );\n\n  updateCartItemQuantity$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(CartActions.updateCartItemQuantity),\n      map(action => ({ productId: action.productId, quantity: action.quantity })), // Extract properties\n      withLatestFrom(\n        this.store.select(selectCartItems),\n        this.store.select(selectIsAuthenticated)\n      ),\n      exhaustMap(([{ productId, quantity }, currentItems, isAuthenticated]) => { // Use extracted properties\n        const updatedItems = currentItems.map(item => \n          item.productId === productId ? { ...item, quantity } : item\n        );\n        \n        this.storageService.setItem('cart', JSON.stringify(updatedItems));\n\n        if (isAuthenticated) {\n          return this.cartService.syncCart(updatedItems).pipe(\n            map(() => CartActions.syncCartWithServerSuccess()),\n            catchError(error => of(CartActions.syncCartWithServerFailure({ error })))\n          );\n        }\n        \n        return of(CartActions.syncCartWithServerSuccess());\n      })\n    )\n  );\n\n  clearCart$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(CartActions.clearCart),\n      withLatestFrom(this.store.select(selectIsAuthenticated)),\n      exhaustMap(([action, isAuthenticated]) => {\n        if (isAuthenticated) {\n          // Simulate API call to clear backend cart\n          return of({ type: '[Cart API] Clear Cart Success - Backend (Placeholder)' }).pipe(\n            map(() => CartActions.loadCartSuccess({ items: [] })),\n            catchError(error => of({ type: '[Cart API] Clear Cart Failure - Backend', error }))\n          );\n        } else {\n          // For non-authenticated users, just return success\n          return of(CartActions.loadCartSuccess({ items: [] }));\n        }\n      })\n    )\n  );\n\n  constructor(\n    private actions$: Actions,\n    private cartService: CartService,\n    private storageService: StorageService,\n    private notificationService: NotificationService,\n    private store: Store<AppState>\n  ) {}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}