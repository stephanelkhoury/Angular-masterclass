{"ast":null,"code":"import { createEffect, ofType } from '@ngrx/effects';\nimport { of } from 'rxjs';\nimport { map, catchError, exhaustMap, tap, withLatestFrom } from 'rxjs/operators';\nimport * as CartActions from '../actions/cart.actions';\nimport { selectCartItems } from '../selectors/cart.selectors';\nimport { selectIsAuthenticated } from '../selectors/auth.selectors';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/effects\";\nimport * as i2 from \"../../core/services/cart.service\";\nimport * as i3 from \"../../core/services/storage.service\";\nimport * as i4 from \"../../core/services/notification.service\";\nimport * as i5 from \"@ngrx/store\";\nclass CartEffects {\n  constructor(actions$, cartService, storageService, notificationService, store) {\n    this.actions$ = actions$;\n    this.cartService = cartService;\n    this.storageService = storageService;\n    this.notificationService = notificationService;\n    this.store = store;\n    this.loadCart$ = createEffect(() => this.actions$.pipe(ofType(CartActions.loadCart), withLatestFrom(this.store.select(selectIsAuthenticated)), exhaustMap(([_, isAuthenticated]) => {\n      if (isAuthenticated) {\n        return this.cartService.getCart().pipe(map(items => CartActions.loadCartSuccess({\n          items\n        })), catchError(error => of(CartActions.loadCartFailure({\n          error\n        }))));\n      } else {\n        const localCart = this.storageService.getItem('cart') || '[]';\n        try {\n          const items = JSON.parse(localCart);\n          return of(CartActions.loadCartSuccess({\n            items\n          }));\n        } catch (error) {\n          return of(CartActions.loadCartFailure({\n            error: 'Failed to parse cart data'\n          }));\n        }\n      }\n    })));\n    this.addToCart$ = createEffect(() => this.actions$.pipe(ofType(CartActions.addToCart), map(action => action.item),\n    // Extract the item from the action\n    withLatestFrom(this.store.select(selectCartItems), this.store.select(selectIsAuthenticated)), tap(([{\n      productId,\n      quantity\n    }, _, __]) => {\n      this.notificationService.showSuccess(`${productId} added to cart`);\n    }), exhaustMap(([item, currentItems, isAuthenticated]) => {\n      if (isAuthenticated) {\n        // Simulate API call to add item to backend cart\n        return of({\n          type: '[Cart API] Add Item Success - Backend (Placeholder)',\n          payload: item\n        }).pipe(map(() => CartActions.loadCartSuccess({\n          items: [...currentItems, {\n            productId: item.productId,\n            quantity: item.quantity,\n            name: item.name || '',\n            price: item.price,\n            image: item.image || item.imageUrl || '',\n            unitPrice: item.unitPrice || item.price\n          }]\n        })), catchError(error => of(CartActions.loadCartFailure({\n          error\n        }))));\n      } else {\n        const cartItem = {\n          productId: item.productId,\n          name: item.name,\n          price: item.price,\n          image: item.imageUrl || '',\n          quantity: item.quantity\n        };\n        const updatedItems = [...currentItems];\n        const existingItemIndex = updatedItems.findIndex(cartItem => cartItem.productId === item.productId);\n        if (existingItemIndex >= 0) {\n          updatedItems[existingItemIndex] = {\n            ...updatedItems[existingItemIndex],\n            quantity: updatedItems[existingItemIndex].quantity + item.quantity\n          };\n        } else {\n          updatedItems.push(cartItem);\n        }\n        this.storageService.setItem('cart', JSON.stringify(updatedItems));\n        return of(CartActions.syncCartWithServerSuccess());\n      }\n    })));\n    this.removeFromCart$ = createEffect(() => this.actions$.pipe(ofType(CartActions.removeFromCart), map(action => action.productId),\n    // Extract productId\n    withLatestFrom(this.store.select(selectCartItems), this.store.select(selectIsAuthenticated)), tap(([productId, currentItems, _]) => {\n      const item = currentItems.find(item => item.productId === productId);\n      if (item) {\n        this.notificationService.showInfo(`${item.name} removed from cart`);\n      }\n    }), exhaustMap(([productId, currentItems, isAuthenticated]) => {\n      const updatedItems = currentItems.filter(item => item.productId !== productId);\n      this.storageService.setItem('cart', JSON.stringify(updatedItems));\n      if (isAuthenticated) {\n        return this.cartService.syncCart(updatedItems).pipe(map(() => CartActions.syncCartWithServerSuccess()), catchError(error => of(CartActions.syncCartWithServerFailure({\n          error\n        }))));\n      }\n      return of(CartActions.syncCartWithServerSuccess());\n    })));\n    this.updateCartItemQuantity$ = createEffect(() => this.actions$.pipe(ofType(CartActions.updateCartItemQuantity), map(action => ({\n      productId: action.productId,\n      quantity: action.quantity\n    })),\n    // Extract properties\n    withLatestFrom(this.store.select(selectCartItems), this.store.select(selectIsAuthenticated)), exhaustMap(([{\n      productId,\n      quantity\n    }, currentItems, isAuthenticated]) => {\n      const updatedItems = currentItems.map(item => item.productId === productId ? {\n        ...item,\n        quantity\n      } : item);\n      this.storageService.setItem('cart', JSON.stringify(updatedItems));\n      if (isAuthenticated) {\n        return this.cartService.syncCart(updatedItems).pipe(map(() => CartActions.syncCartWithServerSuccess()), catchError(error => of(CartActions.syncCartWithServerFailure({\n          error\n        }))));\n      }\n      return of(CartActions.syncCartWithServerSuccess());\n    })));\n    this.clearCart$ = createEffect(() => this.actions$.pipe(ofType(CartActions.clearCart), withLatestFrom(this.store.select(selectIsAuthenticated)), exhaustMap(([action, isAuthenticated]) => {\n      if (isAuthenticated) {\n        // Simulate API call to clear backend cart\n        return of({\n          type: '[Cart API] Clear Cart Success - Backend (Placeholder)'\n        }).pipe(map(() => CartActions.loadCartSuccess({\n          items: []\n        })), catchError(error => of({\n          type: '[Cart API] Clear Cart Failure - Backend',\n          error\n        })));\n      } else {\n        // For non-authenticated users, just return success\n        return of(CartActions.loadCartSuccess({\n          items: []\n        }));\n      }\n    })));\n  }\n  static {\n    this.ɵfac = function CartEffects_Factory(t) {\n      return new (t || CartEffects)(i0.ɵɵinject(i1.Actions), i0.ɵɵinject(i2.CartService), i0.ɵɵinject(i3.StorageService), i0.ɵɵinject(i4.NotificationService), i0.ɵɵinject(i5.Store));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: CartEffects,\n      factory: CartEffects.ɵfac\n    });\n  }\n}\nexport { CartEffects };","map":{"version":3,"names":["createEffect","ofType","of","map","catchError","exhaustMap","tap","withLatestFrom","CartActions","selectCartItems","selectIsAuthenticated","CartEffects","constructor","actions$","cartService","storageService","notificationService","store","loadCart$","pipe","loadCart","select","_","isAuthenticated","getCart","items","loadCartSuccess","error","loadCartFailure","localCart","getItem","JSON","parse","addToCart$","addToCart","action","item","productId","quantity","__","showSuccess","currentItems","type","payload","name","price","image","imageUrl","unitPrice","cartItem","updatedItems","existingItemIndex","findIndex","push","setItem","stringify","syncCartWithServerSuccess","removeFromCart$","removeFromCart","find","showInfo","filter","syncCart","syncCartWithServerFailure","updateCartItemQuantity$","updateCartItemQuantity","clearCart$","clearCart","i0","ɵɵinject","i1","Actions","i2","CartService","i3","StorageService","i4","NotificationService","i5","Store","factory","ɵfac"],"sources":["/Users/stephanelkhoury/Documents/GitHub/Angular-masterclass/Ecommerce-Project/code-examples/angular-ecommerce/src/app/store/effects/cart.effects.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport { Store } from '@ngrx/store';\nimport { of } from 'rxjs';\nimport { map, catchError, exhaustMap, tap, withLatestFrom } from 'rxjs/operators';\n\nimport { CartService } from '../../core/services/cart.service';\nimport { NotificationService } from '../../core/services/notification.service';\nimport { StorageService } from '../../core/services/storage.service';\nimport { CartItem } from '../../core/models/cart-item.model';\nimport { AppState } from '../index';\nimport * as CartActions from '../actions/cart.actions';\nimport * as UiActions from '../actions/ui.actions';\nimport { selectCartItems } from '../selectors/cart.selectors';\nimport { selectIsAuthenticated } from '../selectors/auth.selectors';\n\n@Injectable()\nexport class CartEffects {\n  loadCart$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(CartActions.loadCart),\n      withLatestFrom(this.store.select(selectIsAuthenticated)),\n      exhaustMap(([_, isAuthenticated]) => {\n        if (isAuthenticated) {\n          return this.cartService.getCart().pipe(\n            map(items => CartActions.loadCartSuccess({ items })),\n            catchError(error => of(CartActions.loadCartFailure({ error })))\n          );\n        } else {\n          const localCart = this.storageService.getItem<string>('cart') || '[]';\n          try {\n            const items = JSON.parse(localCart);\n            return of(CartActions.loadCartSuccess({ items }));\n          } catch (error) {\n            return of(CartActions.loadCartFailure({ error: 'Failed to parse cart data' }));\n          }\n        }\n      })\n    )\n  );\n\n  addToCart$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(CartActions.addToCart),\n      map(action => action.item), // Extract the item from the action\n      withLatestFrom(\n        this.store.select(selectCartItems),\n        this.store.select(selectIsAuthenticated)\n      ),\n      tap(([{ productId, quantity }, _, __]) => { // Destructure from the extracted item\n        this.notificationService.showSuccess(`${productId} added to cart`);\n      }),\n      exhaustMap(([item, currentItems, isAuthenticated]) => {\n        if (isAuthenticated) {\n          // Simulate API call to add item to backend cart\n          return of({ type: '[Cart API] Add Item Success - Backend (Placeholder)', payload: item }).pipe(\n            map(() => CartActions.loadCartSuccess({ \n              items: [...currentItems, {\n                productId: item.productId,\n                quantity: item.quantity,\n                name: item.name || '',\n                price: item.price,\n                image: item.image || item.imageUrl || '',\n                unitPrice: item.unitPrice || item.price\n              }]\n            })),\n            catchError(error => of(CartActions.loadCartFailure({ error })))\n          );\n        } else {\n          const cartItem: CartItem = {\n            productId: item.productId,\n            name: item.name,\n            price: item.price,\n            image: item.imageUrl || '',\n            quantity: item.quantity\n          };\n\n          const updatedItems = [...currentItems];\n          const existingItemIndex = updatedItems.findIndex(cartItem => cartItem.productId === item.productId);\n\n          if (existingItemIndex >= 0) {\n            updatedItems[existingItemIndex] = {\n              ...updatedItems[existingItemIndex],\n              quantity: updatedItems[existingItemIndex].quantity + item.quantity\n            };\n          } else {\n            updatedItems.push(cartItem);\n          }\n\n          this.storageService.setItem('cart', JSON.stringify(updatedItems));\n\n          return of(CartActions.syncCartWithServerSuccess());\n        }\n      })\n    )\n  );\n\n  removeFromCart$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(CartActions.removeFromCart),\n      map(action => action.productId), // Extract productId\n      withLatestFrom(\n        this.store.select(selectCartItems),\n        this.store.select(selectIsAuthenticated)\n      ),\n      tap(([productId, currentItems, _]) => { // Use extracted productId\n        const item = currentItems.find(item => item.productId === productId);\n        if (item) {\n          this.notificationService.showInfo(`${item.name} removed from cart`);\n        }\n      }),\n      exhaustMap(([productId, currentItems, isAuthenticated]) => { // Use extracted productId\n        const updatedItems = currentItems.filter(item => item.productId !== productId);\n        this.storageService.setItem('cart', JSON.stringify(updatedItems));\n\n        if (isAuthenticated) {\n          return this.cartService.syncCart(updatedItems).pipe(\n            map(() => CartActions.syncCartWithServerSuccess()),\n            catchError(error => of(CartActions.syncCartWithServerFailure({ error })))\n          );\n        }\n        \n        return of(CartActions.syncCartWithServerSuccess());\n      })\n    )\n  );\n\n  updateCartItemQuantity$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(CartActions.updateCartItemQuantity),\n      map(action => ({ productId: action.productId, quantity: action.quantity })), // Extract properties\n      withLatestFrom(\n        this.store.select(selectCartItems),\n        this.store.select(selectIsAuthenticated)\n      ),\n      exhaustMap(([{ productId, quantity }, currentItems, isAuthenticated]) => { // Use extracted properties\n        const updatedItems = currentItems.map(item => \n          item.productId === productId ? { ...item, quantity } : item\n        );\n        \n        this.storageService.setItem('cart', JSON.stringify(updatedItems));\n\n        if (isAuthenticated) {\n          return this.cartService.syncCart(updatedItems).pipe(\n            map(() => CartActions.syncCartWithServerSuccess()),\n            catchError(error => of(CartActions.syncCartWithServerFailure({ error })))\n          );\n        }\n        \n        return of(CartActions.syncCartWithServerSuccess());\n      })\n    )\n  );\n\n  clearCart$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(CartActions.clearCart),\n      withLatestFrom(this.store.select(selectIsAuthenticated)),\n      exhaustMap(([action, isAuthenticated]) => {\n        if (isAuthenticated) {\n          // Simulate API call to clear backend cart\n          return of({ type: '[Cart API] Clear Cart Success - Backend (Placeholder)' }).pipe(\n            map(() => CartActions.loadCartSuccess({ items: [] })),\n            catchError(error => of({ type: '[Cart API] Clear Cart Failure - Backend', error }))\n          );\n        } else {\n          // For non-authenticated users, just return success\n          return of(CartActions.loadCartSuccess({ items: [] }));\n        }\n      })\n    )\n  );\n\n  constructor(\n    private actions$: Actions,\n    private cartService: CartService,\n    private storageService: StorageService,\n    private notificationService: NotificationService,\n    private store: Store<AppState>\n  ) {}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}