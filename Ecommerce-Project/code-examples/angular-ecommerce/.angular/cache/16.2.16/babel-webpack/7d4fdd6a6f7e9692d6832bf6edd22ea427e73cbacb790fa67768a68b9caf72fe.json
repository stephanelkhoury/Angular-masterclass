{"ast":null,"code":"import { map, of } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nclass FakeStoreApiService {\n  constructor(http) {\n    this.http = http;\n    this.baseUrl = 'https://fakestoreapi.com';\n  }\n  // Get all products from Fake Store API\n  getProducts(options = {}) {\n    let url = `${this.baseUrl}/products`;\n    // Handle category filtering\n    if (options.category && options.category !== 'all') {\n      url = `${this.baseUrl}/products/category/${encodeURIComponent(options.category)}`;\n    }\n    // Add query parameters\n    const params = new URLSearchParams();\n    if (options.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options.sortBy) {\n      params.append('sort', options.order || 'asc');\n    }\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n    return this.http.get(url).pipe(map(products => this.transformToAppProducts(products, options)), catchError(error => {\n      console.error('Error fetching products from Fake Store API:', error);\n      return of(this.getEmptyResponse());\n    }));\n  }\n  // Get product by ID\n  getProductById(id) {\n    return this.http.get(`${this.baseUrl}/products/${id}`).pipe(map(product => this.transformSingleProduct(product)), catchError(error => {\n      console.error('Error fetching product by ID:', error);\n      return of(null);\n    }));\n  }\n  // Get all categories\n  getCategories() {\n    return this.http.get(`${this.baseUrl}/products/categories`).pipe(map(categories => this.transformToAppCategories(categories)), catchError(error => {\n      console.error('Error fetching categories:', error);\n      return of([]);\n    }));\n  }\n  // Get products in a specific category\n  getProductsByCategory(categoryName, limit) {\n    let url = `${this.baseUrl}/products/category/${encodeURIComponent(categoryName)}`;\n    if (limit) {\n      url += `?limit=${limit}`;\n    }\n    return this.http.get(url).pipe(map(products => products.map(p => this.transformSingleProduct(p))), catchError(error => {\n      console.error('Error fetching products by category:', error);\n      return of([]);\n    }));\n  }\n  // Transform Fake Store API product to your app's Product interface\n  transformSingleProduct(fakeProduct) {\n    return {\n      id: fakeProduct.id.toString(),\n      name: fakeProduct.title,\n      description: fakeProduct.description,\n      price: fakeProduct.price,\n      imageUrl: fakeProduct.image,\n      images: [{\n        id: '1',\n        url: fakeProduct.image,\n        altText: fakeProduct.title\n      }],\n      category: {\n        id: fakeProduct.category,\n        name: this.capitalizeCategory(fakeProduct.category)\n      },\n      categoryId: fakeProduct.category,\n      stock: Math.floor(Math.random() * 100) + 1,\n      stockQuantity: Math.floor(Math.random() * 100) + 1,\n      rating: fakeProduct.rating.rate,\n      brand: this.generateBrandFromCategory(fakeProduct.category),\n      sku: `FS-${fakeProduct.id}`,\n      createdAt: new Date(),\n      featured: Math.random() > 0.7,\n      regularPrice: fakeProduct.price * 1.2,\n      discountPrice: Math.random() > 0.5 ? fakeProduct.price : undefined,\n      availabilityStatus: 'in-stock',\n      freeShipping: Math.random() > 0.6,\n      fastDelivery: Math.random() > 0.7,\n      reviews: this.generateMockReviews(fakeProduct.id.toString(), fakeProduct.rating.count)\n    };\n  }\n  // Transform multiple products\n  transformToAppProducts(fakeProducts, options) {\n    let products = fakeProducts.map(p => this.transformSingleProduct(p));\n    // Apply search filter if provided\n    if (options.search) {\n      const searchTerm = options.search.toLowerCase();\n      products = products.filter(p => p.name.toLowerCase().includes(searchTerm) || p.description.toLowerCase().includes(searchTerm) || p.category?.name.toLowerCase().includes(searchTerm));\n    }\n    // Calculate pagination\n    const page = options.page || 1;\n    const limit = options.limit || products.length;\n    const startIndex = (page - 1) * limit;\n    const endIndex = startIndex + limit;\n    const paginatedProducts = products.slice(startIndex, endIndex);\n    return {\n      items: paginatedProducts,\n      totalCount: products.length,\n      page: page,\n      limit: limit,\n      totalPages: Math.ceil(products.length / limit)\n    };\n  }\n  // Transform categories\n  transformToAppCategories(categories) {\n    return categories.map(cat => ({\n      id: cat,\n      name: this.capitalizeCategory(cat),\n      featured: Math.random() > 0.5 // Randomly mark some as featured\n    }));\n  }\n  // Helper methods\n  capitalizeCategory(category) {\n    return category.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');\n  }\n  generateBrandFromCategory(category) {\n    const brandMap = {\n      'electronics': ['Apple', 'Samsung', 'Sony', 'LG', 'Microsoft'],\n      'jewelery': ['Tiffany & Co.', 'Cartier', 'Pandora', 'Swarovski'],\n      \"men's clothing\": ['Nike', 'Adidas', 'Levi\\'s', 'Calvin Klein', 'Tommy Hilfiger'],\n      \"women's clothing\": ['Zara', 'H&M', 'Forever 21', 'ASOS', 'Mango']\n    };\n    const brands = brandMap[category] || ['Generic Brand'];\n    return brands[Math.floor(Math.random() * brands.length)];\n  }\n  generateMockReviews(productId, count) {\n    // Generate a few mock reviews based on the count\n    const maxReviews = Math.min(count, 5);\n    const reviews = [];\n    for (let i = 0; i < maxReviews; i++) {\n      reviews.push({\n        id: `${productId}-review-${i}`,\n        productId: productId,\n        userId: `user-${i}`,\n        userName: `Customer ${i + 1}`,\n        rating: Math.floor(Math.random() * 5) + 1,\n        comment: 'Great product! Highly recommended.',\n        createdAt: new Date()\n      });\n    }\n    return reviews;\n  }\n  getEmptyResponse() {\n    return {\n      items: [],\n      totalCount: 0,\n      page: 1,\n      limit: 10,\n      totalPages: 0\n    };\n  }\n  static {\n    this.ɵfac = function FakeStoreApiService_Factory(t) {\n      return new (t || FakeStoreApiService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: FakeStoreApiService,\n      factory: FakeStoreApiService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\nexport { FakeStoreApiService };","map":{"version":3,"names":["map","of","catchError","FakeStoreApiService","constructor","http","baseUrl","getProducts","options","url","category","encodeURIComponent","params","URLSearchParams","limit","append","toString","sortBy","order","queryString","get","pipe","products","transformToAppProducts","error","console","getEmptyResponse","getProductById","id","product","transformSingleProduct","getCategories","categories","transformToAppCategories","getProductsByCategory","categoryName","p","fakeProduct","name","title","description","price","imageUrl","image","images","altText","capitalizeCategory","categoryId","stock","Math","floor","random","stockQuantity","rating","rate","brand","generateBrandFromCategory","sku","createdAt","Date","featured","regularPrice","discountPrice","undefined","availabilityStatus","freeShipping","fastDelivery","reviews","generateMockReviews","count","fakeProducts","search","searchTerm","toLowerCase","filter","includes","page","length","startIndex","endIndex","paginatedProducts","slice","items","totalCount","totalPages","ceil","cat","split","word","charAt","toUpperCase","join","brandMap","brands","productId","maxReviews","min","i","push","userId","userName","comment","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["/Users/stephanelkhoury/Documents/GitHub/Angular-masterclass/Ecommerce-Project/code-examples/angular-ecommerce/src/app/core/services/fake-store-api.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, map, forkJoin, of } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nimport { Product, Category, PaginatedResponse } from '../models/product.model';\n\n// Fake Store API interfaces\nexport interface FakeStoreProduct {\n  id: number;\n  title: string;\n  price: number;\n  description: string;\n  category: string;\n  image: string;\n  rating: {\n    rate: number;\n    count: number;\n  };\n}\n\nexport interface FakeStoreCategory {\n  name: string;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class FakeStoreApiService {\n  private baseUrl = 'https://fakestoreapi.com';\n\n  constructor(private http: HttpClient) {}\n\n  // Get all products from Fake Store API\n  getProducts(options: {\n    page?: number;\n    limit?: number;\n    sortBy?: string;\n    order?: 'asc' | 'desc';\n    category?: string;\n    search?: string;\n  } = {}): Observable<PaginatedResponse<Product>> {\n    \n    let url = `${this.baseUrl}/products`;\n    \n    // Handle category filtering\n    if (options.category && options.category !== 'all') {\n      url = `${this.baseUrl}/products/category/${encodeURIComponent(options.category)}`;\n    }\n    \n    // Add query parameters\n    const params = new URLSearchParams();\n    if (options.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options.sortBy) {\n      params.append('sort', options.order || 'asc');\n    }\n    \n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    return this.http.get<FakeStoreProduct[]>(url).pipe(\n      map(products => this.transformToAppProducts(products, options)),\n      catchError(error => {\n        console.error('Error fetching products from Fake Store API:', error);\n        return of(this.getEmptyResponse());\n      })\n    );\n  }\n\n  // Get product by ID\n  getProductById(id: string): Observable<Product | null> {\n    return this.http.get<FakeStoreProduct>(`${this.baseUrl}/products/${id}`).pipe(\n      map(product => this.transformSingleProduct(product)),\n      catchError(error => {\n        console.error('Error fetching product by ID:', error);\n        return of(null);\n      })\n    );\n  }\n\n  // Get all categories\n  getCategories(): Observable<Category[]> {\n    return this.http.get<string[]>(`${this.baseUrl}/products/categories`).pipe(\n      map(categories => this.transformToAppCategories(categories)),\n      catchError(error => {\n        console.error('Error fetching categories:', error);\n        return of([]);\n      })\n    );\n  }\n\n  // Get products in a specific category\n  getProductsByCategory(categoryName: string, limit?: number): Observable<Product[]> {\n    let url = `${this.baseUrl}/products/category/${encodeURIComponent(categoryName)}`;\n    if (limit) {\n      url += `?limit=${limit}`;\n    }\n\n    return this.http.get<FakeStoreProduct[]>(url).pipe(\n      map(products => products.map(p => this.transformSingleProduct(p))),\n      catchError(error => {\n        console.error('Error fetching products by category:', error);\n        return of([]);\n      })\n    );\n  }\n\n  // Transform Fake Store API product to your app's Product interface\n  private transformSingleProduct(fakeProduct: FakeStoreProduct): Product {\n    return {\n      id: fakeProduct.id.toString(),\n      name: fakeProduct.title,\n      description: fakeProduct.description,\n      price: fakeProduct.price,\n      imageUrl: fakeProduct.image,\n      images: [{ id: '1', url: fakeProduct.image, altText: fakeProduct.title }],\n      category: {\n        id: fakeProduct.category,\n        name: this.capitalizeCategory(fakeProduct.category)\n      },\n      categoryId: fakeProduct.category,\n      stock: Math.floor(Math.random() * 100) + 1, // Random stock since API doesn't provide\n      stockQuantity: Math.floor(Math.random() * 100) + 1,\n      rating: fakeProduct.rating.rate,\n      brand: this.generateBrandFromCategory(fakeProduct.category),\n      sku: `FS-${fakeProduct.id}`,\n      createdAt: new Date(),\n      featured: Math.random() > 0.7, // Randomly mark some as featured\n      regularPrice: fakeProduct.price * 1.2, // Simulate original price\n      discountPrice: Math.random() > 0.5 ? fakeProduct.price : undefined,\n      availabilityStatus: 'in-stock' as const,\n      freeShipping: Math.random() > 0.6,\n      fastDelivery: Math.random() > 0.7,\n      reviews: this.generateMockReviews(fakeProduct.id.toString(), fakeProduct.rating.count)\n    };\n  }\n\n  // Transform multiple products\n  private transformToAppProducts(\n    fakeProducts: FakeStoreProduct[], \n    options: any\n  ): PaginatedResponse<Product> {\n    let products = fakeProducts.map(p => this.transformSingleProduct(p));\n    \n    // Apply search filter if provided\n    if (options.search) {\n      const searchTerm = options.search.toLowerCase();\n      products = products.filter(p => \n        p.name.toLowerCase().includes(searchTerm) ||\n        p.description.toLowerCase().includes(searchTerm) ||\n        p.category?.name.toLowerCase().includes(searchTerm)\n      );\n    }\n\n    // Calculate pagination\n    const page = options.page || 1;\n    const limit = options.limit || products.length;\n    const startIndex = (page - 1) * limit;\n    const endIndex = startIndex + limit;\n    const paginatedProducts = products.slice(startIndex, endIndex);\n\n    return {\n      items: paginatedProducts,\n      totalCount: products.length,\n      page: page,\n      limit: limit,\n      totalPages: Math.ceil(products.length / limit)\n    };\n  }\n\n  // Transform categories\n  private transformToAppCategories(categories: string[]): Category[] {\n    return categories.map(cat => ({\n      id: cat,\n      name: this.capitalizeCategory(cat),\n      featured: Math.random() > 0.5 // Randomly mark some as featured\n    }));\n  }\n\n  // Helper methods\n  private capitalizeCategory(category: string): string {\n    return category\n      .split(' ')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  }\n\n  private generateBrandFromCategory(category: string): string {\n    const brandMap: { [key: string]: string[] } = {\n      'electronics': ['Apple', 'Samsung', 'Sony', 'LG', 'Microsoft'],\n      'jewelery': ['Tiffany & Co.', 'Cartier', 'Pandora', 'Swarovski'],\n      \"men's clothing\": ['Nike', 'Adidas', 'Levi\\'s', 'Calvin Klein', 'Tommy Hilfiger'],\n      \"women's clothing\": ['Zara', 'H&M', 'Forever 21', 'ASOS', 'Mango']\n    };\n\n    const brands = brandMap[category] || ['Generic Brand'];\n    return brands[Math.floor(Math.random() * brands.length)];\n  }\n\n  private generateMockReviews(productId: string, count: number): any[] {\n    // Generate a few mock reviews based on the count\n    const maxReviews = Math.min(count, 5);\n    const reviews = [];\n    \n    for (let i = 0; i < maxReviews; i++) {\n      reviews.push({\n        id: `${productId}-review-${i}`,\n        productId: productId,\n        userId: `user-${i}`,\n        userName: `Customer ${i + 1}`,\n        rating: Math.floor(Math.random() * 5) + 1,\n        comment: 'Great product! Highly recommended.',\n        createdAt: new Date()\n      });\n    }\n    \n    return reviews;\n  }\n\n  private getEmptyResponse(): PaginatedResponse<Product> {\n    return {\n      items: [],\n      totalCount: 0,\n      page: 1,\n      limit: 10,\n      totalPages: 0\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}