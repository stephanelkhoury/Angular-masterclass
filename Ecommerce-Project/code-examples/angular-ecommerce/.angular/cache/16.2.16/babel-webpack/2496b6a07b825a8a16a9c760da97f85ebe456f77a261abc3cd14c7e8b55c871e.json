{"ast":null,"code":"import { map, of } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nlet FakeStoreApiService = /*#__PURE__*/(() => {\n  class FakeStoreApiService {\n    constructor(http) {\n      this.http = http;\n      this.baseUrl = 'https://fakestoreapi.com';\n    }\n    // Get all products from Fake Store API\n    getProducts(options = {}) {\n      let url = `${this.baseUrl}/products`;\n      // Handle category filtering\n      if (options.category && options.category !== 'all') {\n        url = `${this.baseUrl}/products/category/${encodeURIComponent(options.category)}`;\n      }\n      // Add query parameters\n      const params = new URLSearchParams();\n      if (options.limit) {\n        params.append('limit', options.limit.toString());\n      }\n      if (options.sortBy) {\n        params.append('sort', options.order || 'asc');\n      }\n      const queryString = params.toString();\n      if (queryString) {\n        url += `?${queryString}`;\n      }\n      return this.http.get(url).pipe(map(products => this.transformToAppProducts(products, options)), catchError(error => {\n        console.error('Error fetching products from Fake Store API:', error);\n        return of(this.getEmptyResponse());\n      }));\n    }\n    // Get product by ID\n    getProductById(id) {\n      return this.http.get(`${this.baseUrl}/products/${id}`).pipe(map(product => this.transformSingleProduct(product)), catchError(error => {\n        console.error('Error fetching product by ID:', error);\n        return of(null);\n      }));\n    }\n    // Get all categories\n    getCategories() {\n      return this.http.get(`${this.baseUrl}/products/categories`).pipe(map(categories => this.transformToAppCategories(categories)), catchError(error => {\n        console.error('Error fetching categories:', error);\n        return of([]);\n      }));\n    }\n    // Get products in a specific category\n    getProductsByCategory(categoryName, limit) {\n      let url = `${this.baseUrl}/products/category/${encodeURIComponent(categoryName)}`;\n      if (limit) {\n        url += `?limit=${limit}`;\n      }\n      return this.http.get(url).pipe(map(products => products.map(p => this.transformSingleProduct(p))), catchError(error => {\n        console.error('Error fetching products by category:', error);\n        return of([]);\n      }));\n    }\n    // Transform Fake Store API product to your app's Product interface\n    transformSingleProduct(fakeProduct) {\n      return {\n        id: fakeProduct.id.toString(),\n        name: fakeProduct.title,\n        description: fakeProduct.description,\n        price: fakeProduct.price,\n        imageUrl: fakeProduct.image,\n        images: [{\n          id: '1',\n          url: fakeProduct.image,\n          altText: fakeProduct.title\n        }],\n        category: {\n          id: fakeProduct.category,\n          name: this.capitalizeCategory(fakeProduct.category)\n        },\n        categoryId: fakeProduct.category,\n        stock: Math.floor(Math.random() * 100) + 1,\n        stockQuantity: Math.floor(Math.random() * 100) + 1,\n        rating: fakeProduct.rating.rate,\n        brand: this.generateBrandFromCategory(fakeProduct.category),\n        sku: `FS-${fakeProduct.id}`,\n        createdAt: new Date(),\n        featured: Math.random() > 0.7,\n        regularPrice: fakeProduct.price * 1.2,\n        discountPrice: Math.random() > 0.5 ? fakeProduct.price : undefined,\n        availabilityStatus: 'in-stock',\n        freeShipping: Math.random() > 0.6,\n        fastDelivery: Math.random() > 0.7,\n        reviews: this.generateMockReviews(fakeProduct.id.toString(), fakeProduct.rating.count)\n      };\n    }\n    // Transform multiple products\n    transformToAppProducts(fakeProducts, options) {\n      let products = fakeProducts.map(p => this.transformSingleProduct(p));\n      // Apply search filter if provided\n      if (options.search) {\n        const searchTerm = options.search.toLowerCase();\n        products = products.filter(p => p.name.toLowerCase().includes(searchTerm) || p.description.toLowerCase().includes(searchTerm) || p.category?.name.toLowerCase().includes(searchTerm));\n      }\n      // Calculate pagination\n      const page = options.page || 1;\n      const limit = options.limit || products.length;\n      const startIndex = (page - 1) * limit;\n      const endIndex = startIndex + limit;\n      const paginatedProducts = products.slice(startIndex, endIndex);\n      return {\n        items: paginatedProducts,\n        totalCount: products.length,\n        page: page,\n        limit: limit,\n        totalPages: Math.ceil(products.length / limit)\n      };\n    }\n    // Transform categories\n    transformToAppCategories(categories) {\n      return categories.map(cat => ({\n        id: cat,\n        name: this.capitalizeCategory(cat),\n        featured: Math.random() > 0.5 // Randomly mark some as featured\n      }));\n    }\n    // Helper methods\n    capitalizeCategory(category) {\n      return category.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');\n    }\n    generateBrandFromCategory(category) {\n      const brandMap = {\n        'electronics': ['Apple', 'Samsung', 'Sony', 'LG', 'Microsoft'],\n        'jewelery': ['Tiffany & Co.', 'Cartier', 'Pandora', 'Swarovski'],\n        \"men's clothing\": ['Nike', 'Adidas', 'Levi\\'s', 'Calvin Klein', 'Tommy Hilfiger'],\n        \"women's clothing\": ['Zara', 'H&M', 'Forever 21', 'ASOS', 'Mango']\n      };\n      const brands = brandMap[category] || ['Generic Brand'];\n      return brands[Math.floor(Math.random() * brands.length)];\n    }\n    generateMockReviews(productId, count) {\n      // Generate a few mock reviews based on the count\n      const maxReviews = Math.min(count, 5);\n      const reviews = [];\n      for (let i = 0; i < maxReviews; i++) {\n        reviews.push({\n          id: `${productId}-review-${i}`,\n          productId: productId,\n          userId: `user-${i}`,\n          userName: `Customer ${i + 1}`,\n          rating: Math.floor(Math.random() * 5) + 1,\n          comment: 'Great product! Highly recommended.',\n          createdAt: new Date()\n        });\n      }\n      return reviews;\n    }\n    getEmptyResponse() {\n      return {\n        items: [],\n        totalCount: 0,\n        page: 1,\n        limit: 10,\n        totalPages: 0\n      };\n    }\n    static {\n      this.ɵfac = function FakeStoreApiService_Factory(t) {\n        return new (t || FakeStoreApiService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: FakeStoreApiService,\n        factory: FakeStoreApiService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return FakeStoreApiService;\n})();\nexport { FakeStoreApiService };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}