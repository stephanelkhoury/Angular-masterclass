{"ast":null,"code":"import { BehaviorSubject, throwError } from 'rxjs';\nimport { map, catchError, tap } from 'rxjs/operators';\nimport { environment } from '../../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./auth.service\";\nimport * as i3 from \"./storage.service\";\nimport * as i4 from \"./notification.service\";\nlet CartService = /*#__PURE__*/(() => {\n  class CartService {\n    constructor(http, authService, storageService, notificationService) {\n      this.http = http;\n      this.authService = authService;\n      this.storageService = storageService;\n      this.notificationService = notificationService;\n      this.apiUrl = `${environment.apiUrl}/cart`;\n      this.cartSubject = new BehaviorSubject(null);\n      this.cart$ = this.cartSubject.asObservable();\n      this.initCart();\n    }\n    initCart() {\n      // If user is logged in, get cart from API, otherwise from localStorage\n      if (this.authService.isAuthenticated()) {\n        this.getCartFromApi().subscribe();\n      } else {\n        const savedCart = this.storageService.getItem('cart');\n        if (savedCart) {\n          this.cartSubject.next(savedCart);\n        } else {\n          this.createEmptyCart();\n        }\n      }\n    }\n    getCartFromApi() {\n      return this.http.get(this.apiUrl).pipe(tap(cart => this.cartSubject.next(cart)), catchError(error => {\n        this.notificationService.error('Failed to load your cart. Please try again.');\n        return throwError(() => error);\n      }));\n    }\n    addItem(request) {\n      if (this.authService.isAuthenticated()) {\n        return this.http.post(`${this.apiUrl}/items`, request).pipe(tap(cart => {\n          this.cartSubject.next(cart);\n          this.notificationService.success('Item added to cart');\n        }), catchError(error => {\n          this.notificationService.error('Failed to add item to cart. Please try again.');\n          return throwError(() => error);\n        }));\n      } else {\n        // Handle guest cart in local storage\n        return this.addItemToLocalCart(request);\n      }\n    }\n    updateItem(request) {\n      if (this.authService.isAuthenticated()) {\n        return this.http.put(`${this.apiUrl}/items/${request.itemId}`, {\n          quantity: request.quantity\n        }).pipe(tap(cart => {\n          this.cartSubject.next(cart);\n          this.notificationService.success('Cart updated');\n        }), catchError(error => {\n          this.notificationService.error('Failed to update cart. Please try again.');\n          return throwError(() => error);\n        }));\n      } else {\n        // Handle guest cart in local storage\n        return this.updateItemInLocalCart(request);\n      }\n    }\n    removeItem(itemId) {\n      if (this.authService.isAuthenticated()) {\n        return this.http.delete(`${this.apiUrl}/items/${itemId}`).pipe(tap(cart => {\n          this.cartSubject.next(cart);\n          this.notificationService.success('Item removed from cart');\n        }), catchError(error => {\n          this.notificationService.error('Failed to remove item from cart. Please try again.');\n          return throwError(() => error);\n        }));\n      } else {\n        // Handle guest cart in local storage\n        return this.removeItemFromLocalCart(itemId);\n      }\n    }\n    clearCart() {\n      if (this.authService.isAuthenticated()) {\n        return this.http.delete(this.apiUrl).pipe(tap(cart => {\n          this.cartSubject.next(cart);\n          this.notificationService.success('Cart cleared');\n        }), catchError(error => {\n          this.notificationService.error('Failed to clear cart. Please try again.');\n          return throwError(() => error);\n        }));\n      } else {\n        // Handle guest cart in local storage\n        return this.clearLocalCart();\n      }\n    }\n    syncLocalCartToServer() {\n      const localCart = this.cartSubject.value;\n      if (!localCart || localCart.items.length === 0) {\n        return this.getCartFromApi();\n      }\n      // Send all local cart items to the server\n      const items = localCart.items.map(item => ({\n        productId: item.productId,\n        quantity: item.quantity\n      }));\n      return this.http.post(`${this.apiUrl}/sync`, {\n        items\n      }).pipe(tap(cart => {\n        this.cartSubject.next(cart);\n        this.storageService.removeItem('cart');\n      }), catchError(error => {\n        this.notificationService.error('Failed to sync your cart. Please try again.');\n        return throwError(() => error);\n      }));\n    }\n    createEmptyCart() {\n      const emptyCart = {\n        id: `local-${new Date().getTime()}`,\n        items: [],\n        itemCount: 0,\n        subtotal: 0,\n        discount: 0,\n        total: 0,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      };\n      this.cartSubject.next(emptyCart);\n      this.storageService.setItem('cart', emptyCart);\n    }\n    addItemToLocalCart(request) {\n      let cart = this.cartSubject.value;\n      if (!cart) {\n        this.createEmptyCart();\n        cart = this.cartSubject.value;\n      }\n      if (!cart) {\n        return throwError(() => new Error('Failed to initialize cart'));\n      }\n      // Check if the item already exists in the cart\n      const existingItemIndex = cart.items.findIndex(item => item.productId === request.productId);\n      if (existingItemIndex >= 0) {\n        // Update quantity if item already exists\n        const updatedItems = [...cart.items];\n        updatedItems[existingItemIndex] = {\n          ...updatedItems[existingItemIndex],\n          quantity: updatedItems[existingItemIndex].quantity + request.quantity\n        };\n        return this.updateLocalCart({\n          ...cart,\n          items: updatedItems\n        });\n      } else {\n        // Add new item\n        const newItem = {\n          id: `local-item-${new Date().getTime()}`,\n          productId: request.productId,\n          quantity: request.quantity\n        };\n        return this.updateLocalCart({\n          ...cart,\n          items: [...cart.items, newItem]\n        });\n      }\n    }\n    updateItemInLocalCart(request) {\n      const cart = this.cartSubject.value;\n      if (!cart) {\n        return throwError(() => new Error('Cart not initialized'));\n      }\n      const itemIndex = cart.items.findIndex(item => item.id === request.itemId);\n      if (itemIndex < 0) {\n        return throwError(() => new Error('Item not found in cart'));\n      }\n      const updatedItems = [...cart.items];\n      if (request.quantity <= 0) {\n        // Remove the item if quantity is 0 or less\n        updatedItems.splice(itemIndex, 1);\n      } else {\n        // Update the quantity\n        updatedItems[itemIndex] = {\n          ...updatedItems[itemIndex],\n          quantity: request.quantity\n        };\n      }\n      return this.updateLocalCart({\n        ...cart,\n        items: updatedItems\n      });\n    }\n    removeItemFromLocalCart(itemId) {\n      const cart = this.cartSubject.value;\n      if (!cart) {\n        return throwError(() => new Error('Cart not initialized'));\n      }\n      const updatedItems = cart.items.filter(item => item.id !== itemId);\n      return this.updateLocalCart({\n        ...cart,\n        items: updatedItems\n      });\n    }\n    clearLocalCart() {\n      this.createEmptyCart();\n      return this.cart$;\n    }\n    updateLocalCart(cart) {\n      // Recalculate totals (in a real app, we would probably fetch product details first)\n      const updatedCart = {\n        ...cart,\n        itemCount: cart.items.reduce((count, item) => count + item.quantity, 0),\n        updatedAt: new Date().toISOString()\n      };\n      this.cartSubject.next(updatedCart);\n      this.storageService.setItem('cart', updatedCart);\n      this.notificationService.success('Cart updated');\n      return this.cart$.pipe(map(currentCart => {\n        if (!currentCart) {\n          throw new Error('Cart not available');\n        }\n        return currentCart;\n      }));\n    }\n    static {\n      this.ɵfac = function CartService_Factory(t) {\n        return new (t || CartService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.AuthService), i0.ɵɵinject(i3.StorageService), i0.ɵɵinject(i4.NotificationService));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: CartService,\n        factory: CartService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return CartService;\n})();\nexport { CartService };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}